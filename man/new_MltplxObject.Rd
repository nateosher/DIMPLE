% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MltplxObject.R
\name{new_MltplxObject}
\alias{new_MltplxObject}
\title{Creates new \code{MltplxObject} object.}
\usage{
new_MltplxObject(
  x,
  y,
  marks,
  slide_id,
  xrange = NULL,
  yrange = NULL,
  ps = NULL,
  bw = NULL,
  dist_metric = NULL,
  .dist_metric_name = NULL,
  window = NULL
)
}
\arguments{
\item{x}{Vector of x coordinates of cells}

\item{y}{Vector of y coordinates of cells}

\item{marks}{Vector of cell types}

\item{slide_id}{Vector of slide ids, i.e. how should cells be grouped}

\item{xrange}{vector of size 2 with range of x-coordinates. If NULL, will default to c(min(x),max(x))}

\item{yrange}{vector of size 2 with range of y-coordinates. If NULL, will default to c(min(y),max(y))
this parameter. Otherwise, it defaults to the name of the function}

\item{ps}{Optional; if you'd like to generate intensity estimates when
you first create these objects, this will determine the "pixel size," i.e.
the side-length of the squares the domain will be broken up into in order
for the estimation to occur. Required if \code{bw} is passed (and vice versa).
Intensities can also be generated after this object is created.}

\item{bw}{Optional; if you'd like to generate intensity estimates when
you first create these objects, this will determine the "bandwidth" of the
smoothing. Larger values of \code{bw} result in more smoothing; this is not
necessarily a good thing. Required if \code{ps} is passed (and vice versa).
Intensities can also be generated after this object is created.}

\item{dist_metric}{Optional; if you'd like to generate distance matrices
between different cell type intensities, this will be the distance metric
used to do so. Distance matrices can also be generated after this object
is created.}

\item{.dist_metric_name}{Optional; not required, even when a distance
matrix is passed. However, if you'd like to name the distance function
you use something specific, you can pass this name as a string using}
}
\value{
\code{MltplxObject} object
}
\description{
Creates new \code{MltplxObject} object.
}
\examples{
library(dplyr)
set.seed(1234567)
cell_x_values = runif(3000, 0, 600)
cell_y_values = runif(3000, 0, 600)
cell_marks = sample(c("Tumor", "Immune", "Other"), 3000, replace = TRUE)
slide_ids = rep(paste("Slide", 1:10), each = 300)
raw_data_tibble = tibble(
  x = cell_x_values,
  y = cell_y_values,
  marks = cell_marks,
  id = slide_ids
)
# Construct `MltplxObject`
 obj_1 = new_MltplxObject(
   x = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(x),
   y = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(y),
   marks = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(marks),
   slide_id = "Slide 1"
)
print(obj_1)

# Construct `MltplxObject` with intensities
 obj_2 = new_MltplxObject(
   x = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(x),
   y = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(y),
   marks = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(marks),
   slide_id = "Slide 1",
   ps = 10, bw = 30
)
print(obj_2)

# Construct `MltplxObject` with intensities + dist matrices
 obj_3 = new_MltplxObject(
   x = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(x),
   y = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(y),
   marks = raw_data_tibble \%>\% filter(id == "Slide 1") \%>\% pull(marks),
   slide_id = "Slide 1",
   ps = 10, bw = 30,
   dist_metric = cor
)
print(obj_3)

}
